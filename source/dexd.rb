#!/usr/bin/env ruby
# encoding: utf-8

require "cgi"
require "erb"
require "uri"
require "json"
require "yaml"
require "webrick"
require "webrick/https"

DEX_DIR = "<%= DEX_DIR %>"
DEX_VERSION = "<%= @ext_version %>"
DEX_PORT = "<%= DEX_PORT %>"
DEX_HOSTNAME = "<%= DEX_HOSTNAME %>"

Dir.chdir DEX_DIR

# Print help
if (%w(-h --help -help) & ARGV).length > 0
	puts "usage: dexd [-hv]"
	puts "starts dex server in the foreground. kill with <Control>C"
	exit
end

# Print version number
if (%w(-v --version -version) & ARGV).length > 0
	puts "dexd #{DEX_VERSION}"
	exit
end

# String formatting methods for the console
class String
	def console_red; colorize(self, "\e[31m"); end
	def console_green; colorize(self, "\e[32m"); end
	def console_bold; colorize(self, "\e[1m"); end
	def console_underline; colorize(self, "\e[4m"); end
	def colorize(text, color_code)  "#{color_code}#{text}\e[0m" end
	def titleize; split(/(\W)/).map(&:capitalize).join; end
end

# Allow regexes to be concatenated
class Regexp
	def +(re)
		Regexp.new self.source + re.source
	end
end

class DexServer < WEBrick::HTTPServlet::AbstractServlet
	def do_GET(request, response)
		puts "#{Time.now}: #{request.path}"
		begin
			config = YAML::load_file("enabled.yaml")
			# Normalise config file
			config.values.map! do |arr|
				arr.map! {|v| v.to_s}.keep_if{|d| File.directory? d}.sort
			end
		rescue
			abort "Something went wrong while loading enabled.yaml"
		end

		content_types = {
			"css"  => "text/css; charset=utf-8",
			"html" => "text/html; charset=utf-8",
			"js"   => "application/javascript; charset=utf-8",
			"json"   => "application/javascript; charset=utf-8",
			"svg"  => "image/svg+xml; charset=utf-8",
			"png"  => "image/png",
			"edit" => "text/plain"
		}

		rgx = {
			"rsrc" => /(?<filename>[\w \-_\.@]+)\.(?<ext>png|svg|js|css)$/,
			"url" => /^\/?(?<url>[\w\-_]+\.[\w\-_\.]+)/,
			"mod" => /\/(?<mod>[\w\s\-]+)\//,
			"ext" => /\.(?<ext>css|js|html|json|edit)$/
		}

		# Info
		if request.path == "/"
			response.body = config.to_json
			return

		# Site-specific actions
		# /url.com.{css,js,html,json,edit}
		elsif (rgx["url"] + rgx["ext"]).match request.path
			url, ext = $~.captures
			response["Content-Type"] = content_types[ext]

			# TODO: Get original array in map? "h" sux.
			h = url.split(".")
			hostnames = h.each_with_index.map {|v,k| h[k..h.length].join "."}[0...-1]

			available = {}
			enabled = {}

			available["global"] = Dir.glob("global/*/").map {|s| s[0...-1]}
			available["site"] = Dir.glob("{utilities,#{hostnames.join(",")}}/*/").map {|s| s[0...-1]}
			available["all"] = available["global"] | available["site"]

			enabled["global"] = available["global"] & (config["global"] || [])
			enabled["site"] = available["site"] & (config[url] || [])
			enabled["all"] = enabled["global"] | enabled["site"]

			case ext

			# Open module folder in Finder
			# TODO: Improve, allow opening files as well: /edit/site.com/mod/file.ext
			when "edit"
				`open "#{DEX_DIR}#{url}/"`
				response.body = "Opening #{DEX_DIR}#{url}/ in Finder... Done!"
				return

			when "json"

				metadata = {}

				# Get all available modules
				Dir.glob("{global,utilities,*.*}/*/").each do |k|
					k = k[0...-1]
					metadata[k] = {
						"Title" => k.rpartition("/")[2].titleize,
						"Author" => nil,
						"Description" => "No description provided.",
						"URL" => nil
					}
				end

				# Replace lame data with nifty metadata
				Dir.glob("{global,utilities,*.*}/*/info.yaml").each do |y|
					k = y[0...-10]
					metadata[k].merge! Hash[YAML::load_file(y).each_value do |v|
						CGI::escapeHTML(v)
					end]
				end

				toggle = request.query["toggle"].to_s

				if toggle and available["all"].include?(toggle)
					response["Access-Control-Allow-Origin"] = "*"

					scope = available["global"].include?(toggle) ? "global" : "site"

					action = "disabled"
					unless enabled[scope].delete(toggle)
						enabled[scope].push(toggle).sort!
						action = "enabled"
					end

					if enabled[scope].empty?
						config.delete(scope)
					else
						config[scope] = enabled[scope]
					end

					# Write the changes
					File.open("enabled.yaml","w") do |file|
						file.write <<-file_contents
# Generated by Dex #{DEX_VERSION}
# #{Time.now.asctime}
#{YAML::dump config}
						file_contents
					end

					response.body = [action, toggle].to_json
					return
				end

				response.body = {
					"metadata" => metadata,
					"site_available" => available["site"].map!{|v| CGI::escapeHTML(v.to_s)},
					"site_enabled" => enabled["site"].map!{|v| CGI::escapeHTML(v.to_s)},
					"global_available" => available["global"].map!{|v| CGI::escapeHTML(v.to_s)},
					"global_enabled" => enabled["global"].map!{|v| CGI::escapeHTML(v.to_s)}
				}.to_json

			when "css", "js"
				body_prefix = ["/* Dex #{DEX_VERSION} at your service."]
				body = []

				unless enabled["all"].empty?
					body_prefix << "\nEnabled Modules:"
					body_prefix.push *enabled["all"].map {|e| "[+] #{e}"}
					body_prefix << "\nEnabled Files:"

					load_me = Dir.glob("{#{enabled["all"].join(",")}}/*.#{ext}")
					load_me.unshift *Dir.glob("{global,#{url}}/*.js") if ext == "js"

					load_me.each do |file|
						body_prefix << "[+] #{file}"
						body << <<-asset_file

/*# sourceURL=#{file} */
#{IO.read(file)}
/* end #{file} */

						asset_file
					end
				end

				body_prefix << "[x] No #{ext.upcase} files to load." if body.empty?
				body_prefix << "\n*/\n"

				response.body = (body_prefix + body).join "\n"
			end

			return

		# Load a resource if it exists
		# /url.com/module/resource.{css,js,png,svg,html}
		elsif (rgx["url"] + rgx["mod"] + rgx["rsrc"]).match request.path
			url, mod, filename, ext = $~.captures

			file_path = File.join(DEX_DIR, request.path)

			if File.exist?(file_path)
				response["Content-Type"] = content_types[ext]
				response.body = IO.read(file_path)
				return
			end
		end

		response.status = 404
		response.body = "'#{request.path}' does not exist."
	end
end

ssl_info = DATA.read
ssl_cert = ssl_info.scan(/(-----BEGIN CERTIFICATE-----.+?-----END CERTIFICATE-----)/m)[0][0]
ssl_key = ssl_info.scan(/(-----BEGIN RSA PRIVATE KEY-----.+?-----END RSA PRIVATE KEY-----)/m)[0][0]

server_options = {
	:Host => DEX_HOSTNAME,
	:BindAddress => "127.0.0.1",
	:Port => DEX_PORT,
	:Logger => WEBrick::Log.new("/dev/null"),
	:AccessLog => [],
	:SSLEnable => true,
	:SSLVerifyClient => OpenSSL::SSL::VERIFY_NONE,
	:SSLPrivateKey => OpenSSL::PKey::RSA.new(ssl_key),
	:SSLCertificate => OpenSSL::X509::Certificate.new(ssl_cert),
	:SSLCertName => [["CN", WEBrick::Utils::getservername]]
}

server = WEBrick::HTTPServer.new(server_options)
server.mount("/", DexServer)

%w(INT TERM).each {|s| trap(s) { server.shutdown }}

puts "dexd #{DEX_VERSION} at your serviceâ€¦".console_green
server.start
__END__
<%= File.read File.join(SERVER_SOURCE_DIR, "#{DEX_HOSTNAME}.pem") %>